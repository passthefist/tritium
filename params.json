{"name":"Tritium","body":"# Overview\r\n\r\nTritium is a collection of utilities for programming in Lua. It adds functional-style methods for lists, new iterators, table and function manipulation, string operators, and a better print/tostring. Tritium eschews adding a formal object model and instead provides the tools for constructing one. This also allows dealing with tables as simple object-like structures, and basic test fixtures. Much of the inspiration for the design of Tritium comes from Python and JavaScript.\r\n\r\nThe source for much of this code is cobbled together from my own previous projects and added to as I find old, useful Lua code.\r\n\r\nThis page is also used to collect my ideas for Tritum.\r\n\r\n### Iterators\r\n\r\nThough Lua has built in functions for iterating over tables, they iterate over both keys and values. Iterating over the values of a table usually looks like this:\r\n\r\n`for _, v in pairs(tbl) do\r\n  print(v)\r\nend\r\n`\r\n\r\nTritium adds a keys() and vals() iterator. Keys iterates over all non-array keys, and values iterates over all values in the table, so the above can be re-written as:\r\n\r\n`for v in vals(tbl) do\r\n  print(v)\r\nend\r\n`\r\n\r\nThese iterators can take iterables as arugments as well:\r\n\r\n`for k, v in zip(keys(tbl), vals(tbl)) do\r\n  print(v)\r\nend\r\n`\r\n\r\nwhich will be identical to:\r\n\r\n`for k, v in pairs(tbl) do\r\n  print(v)\r\nend\r\n`\r\n\r\nSome other iterators added are:\r\n\r\n`ripairs(tbl)` will iterate over array elements backwards.\r\n\r\n`matches(string,pattern)` will iterate over all matched patterns in the given string.\r\n\r\n`tbls(tbl,tbl,...)` iterates over a set of tables as if they were concatenated, returning key-value pairs.\r\n\r\n`keys(tbl,tbl,...)` iterates over just the keys of a table.\r\n\r\n`vals(tbl,tbl,...)` iterates over just the values of a table.\r\n\r\n`zip(tbl,tbl,...)` iterate over the given tables in 'parallel' as multiple values.\r\n\r\n`props(tbl,tbl)` iterates over *all* the properties of a table, including ones on all prototypes and the __index field of the metatables (and the metatable's metatable, etc.). Does not detect cycles, though, so can result in an infinite loop.\r\n\r\n### Table Helpers\r\n\r\nTables are the backbone of Lua, so Tritium provides helpers that encapsulate common actions applied to tables, and some patterns that are useful but hacky or ugly. Array methods act on only the array part of a table.\r\n\r\n`table.proto(tbl, key_or_tbl, value) or table.index(tbl, key_or_tbl, value)` safely adds values to the __index field of the given table's metatable. If no value is given, and key_or_tbl is a table, then that table's pairs are copied into the table's prototype, replacing collisions.\r\n\r\n`table.hook(tbl, key, func)` safely adds a function to the key of the given table's metatable. If a function already exists, then it is chained onto the existing hook. The key has some aliases, so '__newindex' could also be 'newindex', 'new', 'set', or 'put', or 'add' could be '+'. \r\n\r\n`table.method(tbl, name, func)` puts a method on the table's prototype\r\n\r\n`table.merge(tbl, other)` place the pairs from other into table, not replacing collisions.\r\n\r\n`table.replace(tbl, other)` place the pairs from other into table, replacing collisions.\r\n\r\n`table.inspect(tbl)` dump the table as a human readable string. Not suitable for serialization. \r\n\r\n`table.json(tbl)` serialize the table as json, dropping function types. If given a string, then it parses the string into a live table\r\n\r\n`table.bin(tbl)` compactly serialize the table as a string. This serializes all properties of the table, including metatables and functions. If given a string, parses the the string into a live table\r\n\r\n`table.join(tbl, value)` concat the values of an table into a string, separated by value\r\n\r\n`table.joinkeys(tbl, value)` concat the keys of an table into a string, separated by value\r\n\r\n`table.freeze(tbl)` make a table read only\r\n\r\n`table.keyfor(tbl, val)` returns the key for a given value or nil\r\n\r\n#### These array helpers act on only the array part of the table\r\n\r\n`array.prepend(tbl, value)` adds a value to the beginning of the array.\r\n\r\n`array.push(tbl, value)` adds a value to the end of the array.\r\n\r\n`array.pop(tbl, value)` removes the value at the end of the array and returns that value.\r\n\r\n`array.shift(tbl, value)` removes the value at the begging of the array and returns that value.\r\n\r\n`array.join(tbl, value)` concat the elements of an array into a string, separated by value.\r\n\r\n`array.remove(tbl, index)` remove the value at index and shift all elements left\r\n\r\n`array.indexof(tbl, value)` returns the index of the value in the array\r\n\r\n`array.split(tbl, index)` split the array into two arrays up to the given index, and after. Slicing on index 1 returns the head and tail of the array. Giving no arguments for the index will split the array in half. Creates two new tables.\r\n\r\n`array.cat(tbl, other, ...)` concatenate multiple arrays. \r\n\r\n### Data Structures\r\n\r\nLua tables are usually enough for most problems, and can be used to implement a version of most common structures. However, it's still nice to have real linked lists, sets, and trees. Each structure comes in two versions, rolled and wrapped. Wrapped versions take a table and add functions allowing the table to be used like the wrapping structure. Rolled implementations take no arguments (or a function for some), and implement an optimized version of the structure. For example, wrapped lists are a table with list functions attached, whereas a rolled list is an actual linked list. The same methods are available to both implementations of a structure.\r\n\r\nWrapped Example:\r\n\r\n```lua\r\ntbl = {1,2,3,4,5,6,7}\r\nList(tbl) -- Calling List puts list methods onto the table\r\ntbl = tbl:filter(function (v) return v%2 end)\r\n-- List methods can be chained, and List returns the created list\r\nevens = List(tbl):filter(function (v) return v%2 end))\r\n```\r\n\r\nRolled Example:\r\n\r\n```lua\r\nlist = List() -- Creates empty linked list\r\nlist:add(\"value\",\"thing\",\"stuff\")\r\nprint(list[2]) -- Indexing the list requires iteration\r\n\r\notherlist = List():from({1,2,3,4,5,6})\r\n-- From(table) adds all values to the list, and only works for empty lists\r\n```\r\n\r\nAll structures are iterable:\r\n\r\n```lua\r\nfor item in List({1,2,3,4,5,6})\r\n  print(item)\r\nend\r\n```\r\n\r\nand can be constructed from iterables:\r\n\r\n```lua\r\nsometable = {a=1,b=2,c=3}\r\n\r\nsomelist = List(keys(sometable))\r\n--somelist is [a,b,c]\r\nor\r\n\r\nsomelist = List(pairs(sometable))\r\n--somelist is [[a,1],[b,2],[c,3]]\r\n\r\nor\r\n\r\nsomelist = List(zip(sometable,{\"junk\",\"stuff\"}))\r\n--somelist is [[1,junk],[2,stuff],[3]]\r\n```\r\n\r\nTritium's set structure is similar to Python's, and it's the only structure without significantly different performance depending whether it's wrapped or rolled. Tables are basically sets anyway.\r\n\r\n`Set:add(item)` add the item to the set.\r\n\r\n`Set:contains(item), or Set[item]` check if the set contains item.\r\n\r\n`Set:remove(item)` remove the item from the set and return it.\r\n\r\n`Set:union(set)` union two sets together.\r\n\r\n`Set:intersect(set)` find the intersection of two sets.\r\n\r\n`Set:diff(set)` find the difference between two sets.\r\n\r\n`Set:superset(set)` check if the given set is a superset of the calling set.\r\n\r\n`Set:subset(set)` check if the given set is a subset of the calling set.\r\n\r\nThe tree structure is a collection of nodes (key-value pairs) with parents and children. Indexing the tree will look up the node with that key and return the value. The tree constructor can take a sorting function, making the tree a heap or BST depending how it's used. Accessing a key is still constant time for a wrapped structure.\r\n\r\n`Tree:root()` get the root of the tree.\r\n\r\n`Tree:size()` get the number of elements in the tree.\r\n\r\n`Tree:depth()` get the depth of the tree\r\n\r\n`Tree:heapify(func)` sort the tree using the sort function for the tree. Optionally, passing this a sort function will override the default one from the constructor. If no default function exists, then heapify will make this function default. If neither function exists, heapify does nothing.\r\n\r\n`Tree:rotr(key)`\r\n\r\n`Tree:rotl(key)`\r\n\r\n`Tree:balance()`\r\n\r\nThe following can be called on individual nodes as well as the tree given the key. If called on a node, the key argument may be dropped. Any node parameter may be replaced by a key-value pair or tree itself.\r\n\r\n`Tree:children(key)` \r\n\r\n`Tree:add(key, childnode)`\r\n\r\n`Tree:parent(key, newparent)`\r\n\r\n`Tree:remove(key)` \r\n\r\n`Tree:insert(key, parent, child)` If the key exists it is first removed and it's children inherit the removed node's parent. The node then is placed in between parent and child. \r\n\r\n`Tree:replace(key, node)`\r\n\r\n`Tree:val(key, [keyvaluepair])`\r\n\r\n### List functions\r\n\r\nLua unfortunately lacks map, reduce, filter, etc. Tritium defines these common functions, as well as an each() function to iterate over a list. While redundant with a for loop, each is more in line with these list functions.\r\n\r\n```lua\r\neach(\r\n  map(table, function(v)\r\n    return v+10\r\n  end), print)\r\n```\r\n\r\nTo make things easier to read, these functions are chainable if the table has been wrapped as a list. \r\n\r\n```lua\r\nList(table) :\r\n  map(function(v) \r\n    return v+10\r\n  end):each(print)\r\n```\r\n\r\nIf given a string, map() will try to access that key for every value in the list, and return a new list composed of these values. If given only a function, a list func will return another function which, when called with a table, applies the original function to the table. When called with a function instead, it returns the composition of the two functions.\r\n\r\n```lua\r\nsometable = {1,2,3,4,5}\r\ndouble = map(function(v)\r\n  return 2*v\r\nend)\r\n\r\naddone = map(function(v)\r\n  return v+1\r\nend)\r\n\r\nprint(double(sometable))\r\n--prints {2,4,6,8,10}\r\nprint(addone(double(sometable)))\r\n--prints {3,5,7,9,11}\r\n```\r\n\r\nIf called with two functions, then the second function will be invoked with the new table after the operation has been applied. This, combined with above, allows for function chaining even with a bare table:\r\n\r\n```lua\r\nsometable = {1,2,3,4,5,6,7,8,9}\r\nsomevalue = map(sometable, function(v)\r\n  return v+1\r\nend, filter(function(v)\r\n  return v%2 == 0\r\nend, reduce(fn.add)))\r\n\r\nprint(someval)\r\n--prints 30\r\n```\r\n\r\nList functions return the same type of structure, whether wrapped, rolled, or just a raw table. The effect of which means this code is valid, since List structures return an iterator when called.\r\n\r\n```lua\r\nsomelist = List({1,2,3,4,5,6,7,8,9})\r\nfor item in map(somelist, function(v)\r\n  return v+1\r\nend, filter(function(v)\r\n  return v%2 == 0\r\nend) do\r\n  print(item)\r\nend\r\n--prints 2,4,6,8,10\r\n```\r\n\r\nOther functions are:\r\n\r\n`filter(table, conditionfunc)` returns a new list where all items return true for the given condition function. If conditionfunc is a string, then filters out elements by returning the value for the given key on each element.\r\n\r\n`reduce(table, func)` uses the given function to combine all the elements in the list into a single value\r\n\r\n`detect(table, func)` returns the first value in the list that is true for the given function or nil if no item does\r\n\r\n`compact(table)` removes all empty items from the list. An empty item is nil, or has length 0 using the length operator.\r\n\r\n### Logic helpers\r\n\r\nLua famously lacks a switch/case statement, which is largely not missed. However, there are times when switching on a value is pretty useful, so Tritium provides one. There are many ways to implement these in Lua, and the one Tritium uses is a combination of Roberto Ierusalimschy's suggestion and David Manura's post on the Lua user's wiki. The syntax is as follows:\r\n\r\n```lua\r\ncase(value) {\r\n--value could be happy, sad, angry\r\n  happy = function()\r\n    print(\"Good Day!\") \r\n  end,\r\n  sad = function()\r\n    print(\"I'm \"..value..\" today\")\r\n  end,\r\n  angry = function()\r\n    print(\"Hulk Smash!\")\r\n  end,\r\n}\r\n```\r\n\r\nAnother common case is to switch on the type of the variable. If the given value doesn't match any of the given cases, then Tritium assumes a type is what should be matched against.\r\n\r\n```lua\r\ncase(value) {\r\n  string = function()\r\n    print(\"It's a string\") \r\n  end,\r\n  table = function()\r\n    print(\"It's a table\")\r\n  end,\r\n  function = function()\r\n    print(\"It's a function\")\r\n  end,\r\n  number = function()\r\n    print(\"It's a number\")\r\n  end,\r\n  userdata = function()\r\n    print(\"It's a userdata\")\r\n  end,\r\n}\r\n```\r\n\r\nOf course, the two may be combined as long as \"string\", \"number\", etc. are not valid possibilities for the switched variable. Tritium's case statement will also return the matched value, and the values for cases don't have to be functions. Another possible use is: \r\n\r\n```lua\r\nas_number = case(numberword) {\r\n  one = 1,\r\n  two = 2,\r\n  three = 3,\r\n  four = 4,\r\n  ...\r\n  infinity = math.huge\r\n}\r\n```\r\n\r\nIt's worth noting that these case statements can thrash the garbage collector with so many closures being created in a table that's immediately freed and only used once.\r\n\r\nOther logic helpers include:\r\n\r\n`equal(val1,val2)` compares the two parameters by value. Numbers are compared within a threshold and tables are recursively iterated and tested for equality if no equals method is defined, otherwise compares them using the equals method. Metatables are not tested for equality.\r\n\r\n`blank(string_or_table)` returns false if string_or_table is nil, or has length 0\r\n\r\n`is_f(value)` returns true if value is a function, or a callable table\r\n\r\n`is_t(value)` returns true if value is a table\r\n\r\n`is_u(value)` returns true if value is a userdata\r\n\r\n`is_n(value)` returns true if value is a number\r\n\r\n`is_s(value)` returns true if value is a string\r\n\r\n\r\n(More to be documented)\r\n\r\nExamples\r\n\r\n(More to be documented)","tagline":"Lua extension adding missing patterns from other languages","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}